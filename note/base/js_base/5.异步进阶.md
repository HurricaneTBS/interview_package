# event loop(事件循环/事件轮询)

1. JS 是单线程运行的
2. 异步要基于回调来实现
3. event loop 就是异步回调的实现原理

JS 如何执行？

- 从前到后，一行一行执行
- 如果某一行执行报错，则停止下面代码的执行
- 先把同步代码执行完，再执行异步代码

```js
console.log("Hi");

setTimeout(function cb1() {
  console.log("cb1");
}, 5000);

console.log("Bye");
```

总结 event loop 过程

- 同步代码，一行一行放在 Call Stack 执行
- 遇到异步，会先“记录”下，等待时机（定时、网络请求等）
- 时机到了，就移动到 Callback Queue
- 如果 Call Stack 为空（即同步代码执行完），Event Loop 开始工作
- 然后继续轮询查找

# promise 进阶

回顾 Promise 的基本使用

```js
// 加载图片
function loadImg(src) {
  const p = new Promise((resolve, reject) => {
    const img = document.createElement("img");
    img.onload = () => {
      resolve(img);
    };
    img.onerror = () => {
      const err = new Error(`图片加载失败 ${src}`);
      reject(err);
    };
    img.src = src;
  });
  return p;
}
const url = "https://img.mukewang.com/5a9fc8070001a82402060220-140-140.jpg";
loadImg(url)
  .then((img) => {
    console.log(img.width);
    return img;
  })
  .then((img) => {
    console.log(img.height);
  })
  .catch((ex) => console.error(ex));
```

## Promise 的三种状态

1. 三种状态

pending：正在进行当中

resolved：成功

rejected：失败

2. 状态的表现和变化

pending--->resolved 或者 pending--->rejected

- pending 状态，不会出发 then 和 catch
- resolved 状态，会触发后续的 then 回调函数
- rejected 状态，会触发后续的 catch 回调函数

3. then 和 catch 对状态的影响

then 和 catch 改变状态

- then 正常返回 resolved，里面有报错，则返回 rejected
- catch 正常返回 resolevd，里面有报错，则返回 rejected

# async/await

# 微任务/宏任务

# 题目解析

1. 请描述 event loop（事件循环/事件轮询）的机制，可画图？
2. 什么是宏任务和微任务，两者有什么区别？
3. Promise 有哪三种状态？如何变化的？

# 场景题

1. 题目 1

```js
Promise.resolve()
  .then(() => {
    console.log(1); // 返回的是resolved状态，触发then回调
  })
  .catch(() => {
    console.log(2);
  })
  .then(() => {
    console.log(3);
  });
```

> 答案：1，3

2. 题目 2

```js
Promise.resolve()
  .then(() => {
    console.log(1);
    throw new Error("error1"); // 返回rejected状态，触发catch回调
  })
  .catch(() => {
    console.log(2); // 返回resolved状态，触发then回调
  })
  .then(() => {
    console.log(3); // 返回resolved状态，触发then回调
  });
```

> 答案：1，2，3

3. 题目 3

```js
Promise.resolve()
  .then(() => {
    console.log(1);
    throw new Error("error1"); // 返回rejected状态，触发catch回调
  })
  .catch(() => {
    console.log(2); // 返回resolved状态，触发then回调
  })
  .catch(() => {
    console.log(3);
  });
```

> 答案：1，2
